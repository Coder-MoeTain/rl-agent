"""Gymnasium environment for penetration testing simulation."""
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import requests
from urllib.parse import urljoin
from bs4 import BeautifulSoup
import networkx as nx
from typing import Tuple, Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class PentestEnv(gym.Env):
    """Penetration testing environment using attack graph representation.
    
    The environment simulates web application penetration testing where the agent
    can crawl pages, attempt logins, and test for vulnerabilities like XSS.
    The state is represented as a graph of discovered URLs and endpoints.
    """
    metadata = {"render_modes": ["human", "rgb_array"]}

    def __init__(self, base_url: str = "http://localhost:3000", max_steps: int = 100):
        """Initialize the penetration testing environment.
        
        Args:
            base_url: Base URL of the target application
            max_steps: Maximum steps per episode
        """
        super().__init__()
        self.base_url = base_url
        self.max_steps = max_steps
        self.action_space = spaces.Discrete(8)
        self.observation_space = spaces.Box(low=0.0, high=1.0, shape=(64,), dtype=np.float32)
        
        # Initialize state variables
        self.steps = 0
        self.discovered = set()
        self.last_status = 0
        self.last_len = 0
        self.attack_graph = nx.DiGraph()
        
        # Cache for PageRank computation
        self._pagerank_cache = None
        self._pagerank_cache_size = 0

    def reset(self, seed: Optional[int] = None, options: Optional[Dict[str, Any]] = None) -> Tuple[np.ndarray, Dict[str, Any]]:
        """Reset the environment to initial state.
        
        Args:
            seed: Random seed for reproducibility
            options: Additional options for reset
            
        Returns:
            observation: Initial observation
            info: Additional information
        """
        if seed is not None:
            np.random.seed(seed)
        
        self.steps = 0
        self.discovered = set()
        self.last_status = 0
        self.last_len = 0
        self.attack_graph = nx.DiGraph()
        self._pagerank_cache = None
        self._pagerank_cache_size = 0
        
        info = {
            "discovered_count": 0,
            "vulnerabilities": 0,
            "graph_nodes": 0
        }
        return self._make_obs(), info

    def step(self, action: int) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:
        """Execute one step in the environment.
        
        Args:
            action: Action to take (0-7)
            
        Returns:
            observation: New observation
            reward: Reward for this step
            terminated: Whether episode ended (terminal state)
            truncated: Whether episode was truncated (time limit)
            info: Additional information
        """
        if not self.action_space.contains(action):
            logger.warning(f"Invalid action {action}, using action 0")
            action = 0
            
        self.steps += 1
        reward = -0.01  # Base step penalty
        
        try:
            if action == 0:
                reward += self._action_crawl('/')
            elif action == 1:
                reward += self._action_get('/#/login')
            elif action == 2:
                reward += self._action_get('/rest/feedback')
            elif action == 3:
                reward += self._action_post_login()
            elif action == 4:
                reward += self._action_inject("<script>alert(1)</script>")
            elif action == 5:
                reward += self._action_get('/rest/products')
            elif action == 6:
                reward += self._action_get('/rest/user/whoami')
            elif action == 7:
                reward += self._action_inject("<img src=x onerror=alert(1)>")
            else:
                logger.warning(f"Unhandled action {action}")
                reward += 0.0
        except requests.exceptions.RequestException as e:
            logger.debug(f"Request error: {e}")
            reward -= 0.5
        except Exception as e:
            logger.error(f"Unexpected error in step: {e}", exc_info=True)
            reward -= 0.5
        
        terminated = False  # No natural terminal states
        truncated = self.steps >= self.max_steps
        
        info = {
            "steps": self.steps,
            "discovered_count": len(self.discovered),
            "vulnerabilities": sum(len(self.attack_graph.nodes[n].get('vulns', [])) for n in self.attack_graph.nodes),
            "graph_nodes": self.attack_graph.number_of_nodes(),
            "last_status": self.last_status
        }
        
        return self._make_obs(), float(reward), terminated, truncated, info

    def _fetch(self, path: str) -> Tuple[str, int, str]:
        """Fetch a URL and return response details.
        
        Args:
            path: URL path to fetch
            
        Returns:
            url: Final URL after redirects
            status_code: HTTP status code
            text: Response text
        """
        url = urljoin(self.base_url, path)
        try:
            r = requests.get(url, timeout=5, allow_redirects=True)
            return r.url, r.status_code, r.text
        except requests.exceptions.Timeout:
            logger.debug(f"Timeout fetching {url}")
            return url, 0, ''
        except requests.exceptions.RequestException as e:
            logger.debug(f"Request error fetching {url}: {e}")
            return url, 0, ''
        except Exception as e:
            logger.error(f"Unexpected error fetching {url}: {e}")
            return url, 0, ''

    def _action_crawl(self, path: str = '/') -> float:
        """Crawl a path and discover links.
        
        Args:
            path: URL path to crawl
            
        Returns:
            Reward for this action
        """
        url, status, html = self._fetch(path)
        self._index_response(url, status, html)
        links = self._parse_links(html)
        for link in links:
            full = urljoin(self.base_url, link)
            self.attack_graph.add_node(full)
            self.attack_graph.add_edge(url, full)
            self.discovered.add(full)
        return 1.0

    def _action_get(self, path: str) -> float:
        """Perform a GET request to a path.
        
        Args:
            path: URL path to GET
            
        Returns:
            Reward for this action
        """
        url, status, html = self._fetch(path)
        self._index_response(url, status, html)
        links = self._parse_links(html)
        for link in links:
            full = urljoin(self.base_url, link)
            self.attack_graph.add_node(full)
            self.attack_graph.add_edge(url, full)
            self.discovered.add(full)
        return 0.5 if status == 200 else -0.1

    def _action_post_login(self) -> float:
        """Attempt to login via POST request.
        
        Returns:
            Reward for this action
        """
        url = urljoin(self.base_url, '/rest/user/login')
        try:
            r = requests.post(
                url,
                json={"email": "attacker@example.com", "password": "Password123"},
                timeout=5
            )
            status = r.status_code
            text = r.text
            final_url = r.url
            self._index_response(final_url, status, text)
            if status == 200:
                self.attack_graph.add_node(url)
                self.attack_graph.nodes[url]['login_success'] = True
                return 8.0
            return -0.1
        except requests.exceptions.RequestException as e:
            logger.debug(f"Login request error: {e}")
            return -0.5
        except Exception as e:
            logger.error(f"Unexpected error in login: {e}")
            return -0.5

    def _action_inject(self, payload: str) -> float:
        """Attempt XSS injection via feedback endpoint.
        
        Args:
            payload: XSS payload to inject
            
        Returns:
            Reward for this action
        """
        url = urljoin(self.base_url, '/rest/feedback')
        try:
            r = requests.post(
                url,
                json={"comment": payload, "rating": 1},
                timeout=5
            )
            status = r.status_code
            text = r.text
            final_url = r.url
            self._index_response(final_url, status, text)
            if payload in text:
                self.attack_graph.add_node(url)
                self.attack_graph.nodes[url].setdefault('vulns', []).append({
                    'type': 'XSS',
                    'payload': payload
                })
                return 30.0
            return -0.2
        except requests.exceptions.RequestException as e:
            logger.debug(f"Injection request error: {e}")
            return -1.0
        except Exception as e:
            logger.error(f"Unexpected error in injection: {e}")
            return -1.0

    def _parse_links(self, html: str) -> set:
        """Parse HTML to extract links.
        
        Args:
            html: HTML content to parse
            
        Returns:
            Set of discovered link paths
        """
        soup = BeautifulSoup(html or '', 'html.parser')
        links = set()
        for a in soup.find_all('a', href=True):
            href = a.get('href', '')
            if href.startswith('/'):
                links.add(href)
        return links

    def _index_response(self, url: str, status: int, html: str) -> None:
        """Index a response and update state.
        
        Args:
            url: URL of the response
            status: HTTP status code
            html: Response HTML content
        """
        try:
            self.last_status = status
            self.last_len = len(html)
            self.discovered.add(url)
            self.attack_graph.add_node(url)
            # Invalidate PageRank cache if graph changed
            if self.attack_graph.number_of_nodes() != self._pagerank_cache_size:
                self._pagerank_cache = None
        except Exception as e:
            logger.error(f"Error indexing response: {e}")

    def _graph_features(self) -> np.ndarray:
        """Extract features from the attack graph.
        
        Returns:
            Feature vector of length 60
        """
        G = self.attack_graph
        vec = np.zeros((60,), dtype=np.float32)
        
        if G.number_of_nodes() == 0:
            return vec
        
        # Degree statistics
        degs = [d for _, d in G.degree()]
        deg_mean = float(sum(degs)) / len(degs) if degs else 0.0
        vec[0] = min(deg_mean / 10.0, 1.0)
        
        # Connected components
        und = G.to_undirected()
        comp_sizes = [len(c) for c in nx.connected_components(und)] if und.number_of_nodes() else []
        vec[1] = min(max(comp_sizes) / 50.0, 1.0) if comp_sizes else 0.0
        
        # PageRank (cached for performance)
        try:
            current_size = G.number_of_nodes()
            if self._pagerank_cache is None or self._pagerank_cache_size != current_size:
                self._pagerank_cache = nx.pagerank(G)
                self._pagerank_cache_size = current_size
            top_pr = max(self._pagerank_cache.values()) if self._pagerank_cache else 0.0
            vec[2] = float(top_pr)
        except Exception as e:
            logger.debug(f"PageRank computation error: {e}")
            vec[2] = 0.0
        
        # Vulnerability count
        vulns = sum(len(G.nodes[n].get('vulns', [])) for n in G.nodes)
        vec[3] = min(vulns / 10.0, 1.0)
        
        # Graph size metrics
        vec[4] = min(len(G.nodes) / 200.0, 1.0)
        vec[5] = min(len(self.discovered) / 200.0, 1.0)
        
        # Degree histogram
        deg_hist = [0] * 10
        for d in degs:
            idx = min(d, 9)
            deg_hist[idx] += 1
        total = sum(deg_hist) or 1
        for i in range(10):
            vec[6 + i] = deg_hist[i] / total
        
        # In/out degree statistics
        indeg = [d for _, d in G.in_degree()]
        outdeg = [d for _, d in G.out_degree()]
        vec[16] = min((sum(indeg) / len(indeg)) / 10.0, 1.0) if indeg else 0.0
        vec[17] = min((sum(outdeg) / len(outdeg)) / 10.0, 1.0) if outdeg else 0.0
        
        # Response features
        vec[18] = float(self.last_status) / 600.0
        vec[19] = min(float(self.last_len) / 20000.0, 1.0)
        vec[20] = float(self.steps) / float(self.max_steps)
        
        return vec

    def _make_obs(self):
        vec = np.zeros((64,), dtype=np.float32)
        gfeat = self._graph_features()
        vec[:len(gfeat)] = gfeat
        return vec

    def render(self, mode: str = 'human') -> Optional[np.ndarray]:
        """Render the environment.
        
        Args:
            mode: Rendering mode ('human' or 'rgb_array')
            
        Returns:
            Rendered frame if mode is 'rgb_array', None otherwise
        """
        if mode == 'human':
            vulns = sum(len(self.attack_graph.nodes[n].get('vulns', [])) for n in self.attack_graph.nodes)
            print(f"Steps={self.steps} | Discovered={len(self.discovered)} | "
                  f"Status={self.last_status} | Vulnerabilities={vulns} | "
                  f"Graph Nodes={self.attack_graph.number_of_nodes()}")
        elif mode == 'rgb_array':
            # Return a simple visualization as numpy array
            # For now, return None - can be extended with actual visualization
            return None
        return None
